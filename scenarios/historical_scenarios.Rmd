---
title: "Historical Scenarios"
date: "`r Sys.Date()`"
output:
  bookdown::html_document2:
    fig_caption: yes
---




```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
knitr::opts_knit$set(root.dir = '~/projects/maestria/calibration/scenarios/')
library(tidyverse)
library(ape)
library(ggtree)
library(svglite)
library(wesanderson)

palet <- wes_palette("Darjeeling1")
colors <- c(palet[2],palet[4])
```


This is a document for keeping track of the creation of different evolutionary scenarios that will be used for evaluating the effects of admixture in hapFLK statistics.


For every given topology, I will construct a tree with associated tree lengths (and maybe migration weights) and compute the theoretical covariance matrix.



# Scenarios

I will use a few (relatively simple) scenarios for testing the calibration of hapflk statistic and for testing for selection on admixed populations.


**Set up some useful functions**
```{r}
labeledTreePlot <- function(x){
  ggtree(x) +
  theme_tree2() +
  geom_label(aes(label=label), fill=palet[5]  ) 
}

updateTree <- function( tree, node_labels , branch_lenghs ){
  tbl <- as_tibble(tree)
  query <- tibble(label=node_labels, branch.length = branch_lengths  )
  p <- rows_update(tbl, query )
  return(as.phylo(p))
}

scaleTree <- function( tree, scaling_factor ){
  
  tbl <- as_tibble(tree)
  query <- tibble(label= tbl$label, branch.length = scaling_factor * tbl$branch.length )
  p <- rows_update(tbl, query )
  return(as.phylo(p))
  
}

```


## Treelike scenarios

### Hierarchical simple

Simple scenario for very basic calibration and migration scenarios. An example topology follows:

```{r hSimple, fig.cap="Hierarchical simple" }
tree <- read.tree("trees/hierarchical_simple_sample.nwk")



ggtree(tree) +
  theme_tree2() +
  geom_label(aes(label=label), fill=palet[5]  )
```


**Set up branch lengths**
```{r}
tbl <- as_tibble(tree)
tbl

# New branch lengths
node_labels <- c("p1","p2","p3","p4","A","B","C")
branch_lengths <- c(300,100,100,200,NA,100,100)

# Update tree
#newtree <- updateTree(tree, node_labels = node_labels, branch_lenghs = branch_lengths) 
newtree <- scaleTree(tree, scaling_factor = 10)
# Plot tree
labeledTreePlot(newtree)
```


**Compute theoretical covariance matrix**


```{r}
tbl <- as_tibble(newtree)
# Get brnach coefficients
c2 <- tbl %>% filter(label == "p2") %>% pull(branch.length) 
c3 <- tbl %>% filter(label == "p3") %>% pull(branch.length) 
c4 <- tbl %>% filter(label == "p4") %>% pull(branch.length) 
cC <- tbl %>% filter(label == "C") %>% pull(branch.length) 

# Specify populations and population size
pops <- c("p2","p3","p4")
popsize <- 1000

# Build matrix
m <- matrix( c(c2+cC,   cC, 0,
                  cC,c3+cC, 0,
                   0,    0, c4 ), byrow = TRUE , nrow = 3  )

rownames(m) <- pops
# Compute covariance
Fij <- m * 1/(2*popsize)
# Write matrix
write.table(Fij, "covariance/hierarchical_simple.tab",
            sep =  " ",
            row.names = TRUE,
            col.names = FALSE,
            quote = FALSE)


write.tree(newtree, file = "trees/hierarchical_simple.nwk", append = FALSE,
           digits = 10, tree.names = FALSE)
```




### Hierarchical complex


This is a good scenario for testing:

* How generation time between splits affects the hapFLK statistic.
* How admixture between proximal and distant populations affect the hapFLK statistic.

An example scenario follows:

```{r hComplex, fig.cap="Hierarchical complex"}
tree <- read.tree("trees/hierarchical_complex_sample.nwk")
ggtree(tree) +
  theme_tree2() +
  geom_label(aes(label=label), fill=palet[5]) 
```



**Set up branch lengths**

```{r}
tbl <- as_tibble(tree)
tbl

# New branch lengths
node_labels <-  c("p1","p2","p3","p4","p5","p6","A","B","C","D","E")
branch_lengths<-c( 500, 300, 300, 300 ,200 ,200, 0 ,100,100,100,100)

# Update tree
#newtree <- updateTree(tree, node_labels = node_labels, branch_lenghs = branch_lengths) 
newtree <- scaleTree(tree, scaling_factor = 10)
# Plot tree
labeledTreePlot(newtree)
```


**Compute theoretical covariance matrix**



```{r}
tbl <- as_tibble(newtree)
# Get brnach coefficients
c2 <- tbl %>% filter(label == "p2") %>% pull(branch.length) 
c3 <- tbl %>% filter(label == "p3") %>% pull(branch.length) 
c4 <- tbl %>% filter(label == "p4") %>% pull(branch.length) 
c5 <- tbl %>% filter(label == "p5") %>% pull(branch.length) 
c6 <- tbl %>% filter(label == "p6") %>% pull(branch.length)
cE <- tbl %>% filter(label == "E") %>% pull(branch.length) 
cC <- tbl %>% filter(label == "C") %>% pull(branch.length) 
cD <- tbl %>% filter(label == "D") %>% pull(branch.length) 
# Specify populations and population size
pops <- c("p2","p3","p4","p5","p6")
popsize <- 1000

# Build matrix
m <- matrix( c( c2+cD+cC,    cD+cC,    cC,      0,       0,
                   cD+cC, c3+cD+cC,    cC,      0,       0,
                      cC,       cC, c4+cC,      0,       0,
                       0,        0,     0,  c5+cE,      cE,
                       0,        0,     0,     cE,    c6+cE   ), byrow = TRUE , nrow = 5  )

rownames(m) <- pops

# Compute covariance
Fij <- m * 1/(2*popsize)
Fij
# Write matrix
 write.table(Fij, "covariance/hierarchical_complex.tab", 
             sep =  " ", 
             row.names = TRUE,
             col.names = FALSE,
             quote = FALSE)
 
 
write.tree(newtree, file = "trees/hierarchical_complex.nwk", append = FALSE,
           digits = 10, tree.names = FALSE)
```



## Admixture scenarios


### Admixture simple 

```{r aSimple, fig.cap="Admixture simple" }
tree <- read.tree("trees/hierarchical_simple_sample.nwk")

newtree <- scaleTree(tree, scaling_factor = 10)

plt <- ggtree(newtree) +
      theme_tree2() +
      geom_label(aes(label=label), fill=palet[5]  )

ggsave(plot=plt,filename =  "images/admixture_simple.svg", device = "svg" )

```


This graph structure's allelic frequencies should approximately follow covariance matrix:


$\begin{bmatrix} c_1+c_3 & c_1(1-w) & 0\\ c_1(1-w) & c_1+c_{21}+c_{22} & w(c_1+c_{21}) \\ 0 & w(c_1+c_{21}) & c_{41}(1-w)^2 + (c_1+c_{21})w^2 + c_{42} \end{bmatrix}$


```{r}
tbl <- as_tibble(newtree)
# Get brnach coefficients
c2 <- tbl %>% filter(label == "p2") %>% pull(branch.length) 
c3 <- tbl %>% filter(label == "p3") %>% pull(branch.length) 
c4 <- tbl %>% filter(label == "p4") %>% pull(branch.length) 
c1 <- tbl %>% filter(label == "C") %>% pull(branch.length) 
# Specify populations, population size and migration weights
pops <- c("p2","p3","p4")
popsize <- 1000
w <- 0.3
mgen <- 370 # migration generation after the second split
d <- 1/(2*popsize)
# Separate drift into pre-admixture and post-admixture components

c21 <- mgen - c1
c22 <- c2 - ( mgen - c1 ) 
c41 <- mgen
c42 <- c4 - mgen


# Build matrix
m <- matrix( c(d*(c1+c22+c21),   d*(c1)*(1-w), d*(c1+c21)*w,
                  d*(c1)*(1-w),d*(c3+c1), 0,
                       d*(c1+c21)*w,        0, d*(c41)*(1-w)^2 + d*(c1+c21)*w^2 + d*c42
               
               ), byrow = TRUE , nrow = 3  )

n <- matrix( c((c1+c22+c21),   (c1)*(1-w), (c1+c21)*w,
                  (c1)*(1-w),(c3+c1), 0,
                       (c1+c21)*w,        0, (c41)*(1-w)^2 + (c1+c21)*w^2 + c42
               
               ), byrow = TRUE , nrow = 3  )

rownames(m) <- pops
# 
Fij<- m 

# Write matrix
write.table(Fij, "covariance/admixture_simple.tab",
            sep =  " ",
            row.names = TRUE,
            col.names = FALSE,
            quote = FALSE)

colnames(Fij) <- pops
ord <- c("p3","p2","p4")
Fij[ord,ord]


```





### Admixture complex

```{r aComplex, fig.cap="Admixture complex" }
tree <- read.tree("trees/hierarchical_complex_sample.nwk")

newtree <- scaleTree(tree, scaling_factor = 10)

plt <- ggtree(newtree) +
      theme_tree2() +
      geom_label(aes(label=label), fill=palet[5]  )

ggsave(plot=plt,filename =  "images/admixture_complex.svg", device = "svg" )
labeledTreePlot(newtree)
```




This graph structure's allelic frequencies should approximately follow covariance matrix:


$\begin{bmatrix}c_c + c_d + c_{21} + c_{22} & (c_d+c_c)(1-w)&(c_{21}+c_d+c_c)w & 0 & 0  \\ (c_d+c_c)(1-w)&c_c+c_d+c_3&c_c&0&0 \\ (c_{21}+c_d+c_c)w&c_c&(c_{21}+c_d+c_c)w^2+(c_{41}+c_c)(1-w)^2+c_{42}&0&0 \\0&0&0&c_5+c_e& c_e \\ 0&0&0&c_e&c_6+c_e \end{bmatrix}$

```{r}
tbl <- as_tibble(newtree)
# Get brnach coefficients

c2 <- tbl %>% filter(label == "p2") %>% pull(branch.length) 
c3 <- tbl %>% filter(label == "p3") %>% pull(branch.length) 
c4 <- tbl %>% filter(label == "p4") %>% pull(branch.length) 
c5 <- tbl %>% filter(label == "p5") %>% pull(branch.length) 
c6 <- tbl %>% filter(label == "p6") %>% pull(branch.length)
cE <- tbl %>% filter(label == "E") %>% pull(branch.length) 
cC <- tbl %>% filter(label == "C") %>% pull(branch.length) 
cD <- tbl %>% filter(label == "D") %>% pull(branch.length) 

# Specify populations and population size
pops <- c("p2","p3","p4","p5","p6")
popsize <- 1000
w <- 0.5
mgen <- 570 # migration generation after the second split
d <- 1/(2*popsize)

c21 <- mgen - cD - cC
c22 <- c2 - c21 
c41 <- mgen - cC
c42 <- c4 - c41


# Build matrix
m <- matrix( c( cC+cD+c21+c22, (cD+cC)*(1-w),                                         (c21+cD+cC)*w,       0,           0,
                (cD+cC)*(1-w),      cC+cD+c3,                                                    cC,       0,           0,
                (c21+cD+cC)*w,            cC,                  (c21+cD+cC)*w^2+(c41+cC)*(1-w)^2+c42,       0,           0,
                            0,             0,                                                     0,       c5+cE,       cE,
                            0,             0,                                                     0,       cE,       c6+cE   ), byrow = TRUE , nrow = 5  )

rownames(m) <- pops
m
# Compute covariance
Fij <- m * 1/(2*popsize)
Fij
# Write matrix
write.table(
  Fij,
  "covariance/admixture_complex.tab",
  sep =  " ",
  row.names = TRUE,
  col.names = FALSE,
  quote = FALSE
)



```



### Simple (revamped)




## Serial Splits

```{r sSplits, fig.cap="Serial splits"}
tree <- read.tree("trees/serial_splits_sample.nwk")
ggtree(tree) +
  theme_tree2() +
  geom_label(aes(label=label), fill=palet[5]) 

```

  

